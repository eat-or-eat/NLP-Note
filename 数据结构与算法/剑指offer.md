- [剑指offer](#剑指offer)
  - [栈与队列（简单）](#栈与队列简单)
    - [1.剑指 Offer 09. 用两个栈实现队列](#1剑指-offer-09-用两个栈实现队列)
    - [2.剑指 Offer 30. 包含 min 函数的栈](#2剑指-offer-30-包含-min-函数的栈)
  - [链表（简单）](#链表简单)
    - [3.剑指 Offer 06. 从尾到头打印链表](#3剑指-offer-06-从尾到头打印链表)
    - [4.剑指 Offer 24. 反转链表](#4剑指-offer-24-反转链表)
    - [5.剑指 Offer 35. 复杂链表的复制](#5剑指-offer-35-复杂链表的复制)
  - [字符串（简单）](#字符串简单)
    - [6.剑指 Offer 05. 替换空格](#6剑指-offer-05-替换空格)
    - [7.剑指 Offer 58 - II. 左旋转字符串](#7剑指-offer-58---ii-左旋转字符串)
  - [查找算法（简单）](#查找算法简单)
    - [8.剑指 Offer 03. 数组中重复的数字](#8剑指-offer-03-数组中重复的数字)
    - [9.剑指 Offer 53 - I. 在排序数组中查找数字 I](#9剑指-offer-53---i-在排序数组中查找数字-i)
    - [10.剑指 Offer 53 - II. 0～n-1 中缺失的数字](#10剑指-offer-53---ii-0n-1-中缺失的数字)
  - [查找算法（中等）](#查找算法中等)
    - [11.剑指 Offer 04. 二维数组中的查找](#11剑指-offer-04-二维数组中的查找)
    - [12.剑指 Offer 11. 旋转数组的最小数字](#12剑指-offer-11-旋转数组的最小数字)
    - [13.剑指 Offer 50. 第一个只出现一次的字符](#13剑指-offer-50-第一个只出现一次的字符)
  - [搜索与回溯算法（简单）](#搜索与回溯算法简单)
    - [14.剑指 Offer 32 - I. 从上到下打印二叉树](#14剑指-offer-32---i-从上到下打印二叉树)
    - [15.剑指 Offer 32 - II. 从上到下打印二叉树 II](#15剑指-offer-32---ii-从上到下打印二叉树-ii)
    - [16.剑指 Offer 32 - III. 从上到下打印二叉树 III](#16剑指-offer-32---iii-从上到下打印二叉树-iii)
    - [17.剑指 Offer 26. 树的子结构](#17剑指-offer-26-树的子结构)
    - [18.剑指 Offer 27. 二叉树的镜像](#18剑指-offer-27-二叉树的镜像)
    - [19.剑指 Offer 28. 对称的二叉树](#19剑指-offer-28-对称的二叉树)
  - [动态规划（简单）](#动态规划简单)
    - [20.剑指 Offer 10- I. 斐波那契数列](#20剑指-offer-10--i-斐波那契数列)
    - [21.剑指 Offer 10- II. 青蛙跳台阶问题](#21剑指-offer-10--ii-青蛙跳台阶问题)
    - [22.剑指 Offer 63. 股票的最大利润](#22剑指-offer-63-股票的最大利润)
  - [动态规划（中等）](#动态规划中等)
    - [23.剑指 Offer 42. 连续子数组的最大和](#23剑指-offer-42-连续子数组的最大和)
    - [24.剑指 Offer 47. 礼物的最大价值](#24剑指-offer-47-礼物的最大价值)
    - [25.剑指 Offer 46. 把数字翻译成字符串](#25剑指-offer-46-把数字翻译成字符串)
    - [26.剑指 Offer 48. 最长不含重复字符的子字符串](#26剑指-offer-48-最长不含重复字符的子字符串)
  - [双指针（简单）](#双指针简单)
    - [27.剑指 Offer 18. 删除链表的节点](#27剑指-offer-18-删除链表的节点)
    - [28.剑指 Offer 22. 链表中倒数第 k 个节点](#28剑指-offer-22-链表中倒数第-k-个节点)
    - [29.剑指 Offer 25. 合并两个排序的链表](#29剑指-offer-25-合并两个排序的链表)
    - [30.剑指 Offer 52. 两个链表的第一个公共节点](#30剑指-offer-52-两个链表的第一个公共节点)
    - [31.剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](#31剑指-offer-21-调整数组顺序使奇数位于偶数前面)
    - [32.剑指 Offer 57. 和为 s 的两个数字](#32剑指-offer-57-和为-s-的两个数字)
    - [33.剑指 Offer 58 - I. 翻转单词顺序](#33剑指-offer-58---i-翻转单词顺序)
  - [搜索与回溯算法（中等）](#搜索与回溯算法中等)
    - [34.剑指 Offer 12. 矩阵中的路径](#34剑指-offer-12-矩阵中的路径)
    - [35.剑指 Offer 13. 机器人的运动范围](#35剑指-offer-13-机器人的运动范围)
    - [36.剑指 Offer 34. 二叉树中和为某一值的路径](#36剑指-offer-34-二叉树中和为某一值的路径)
    - [37.剑指 Offer 36. 二叉搜索树与双向链表](#37剑指-offer-36-二叉搜索树与双向链表)
    - [38.剑指 Offer 54. 二叉搜索树的第 k 大节点](#38剑指-offer-54-二叉搜索树的第-k-大节点)
  - [排序（简单）](#排序简单)
    - [39.剑指 Offer 45. 把数组排成最小的数](#39剑指-offer-45-把数组排成最小的数)
# 剑指offer

## 栈与队列（简单）

### 1.剑指 Offer 09. 用两个栈实现队列

```python
class CQueue:

    def __init__(self):
        self.A, self.B = [], []

    def appendTail(self, value: int) -> None:
        self.A.append(value)

    def deleteHead(self) -> int:
        if self.B: return self.B.pop()
        if not self.A: return -1
        while self.A:
            self.B.append(self.A.pop())
        return self.B.pop()


# Your CQueue object will be instantiated and called as such:
# obj = CQueue()
# obj.appendTail(value)
# param_2 = obj.deleteHead()
```

### 2.剑指 Offer 30. 包含 min 函数的栈

```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.A, self.B = [], []

    def push(self, x: int) -> None:
        self.A.append(x)
        if not self.B or self.B[-1] >= x:
            self.B.append(x)

    def pop(self) -> None:
        if self.A.pop() == self.B[-1]:
            self.B.pop()

    def top(self) -> int:
        return self.A[-1]

    def min(self) -> int:
        return self.B[-1]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.min()
```

## 链表（简单）

### 3.剑指 Offer 06. 从尾到头打印链表

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# 递归
class Solution:
    def reversePrint(self, head: ListNode) -> List[int]:
        return self.reversePrint(head.next) + [head.val] if head else []

# 辅助栈
class Solution:
    def reversePrint(self, head: ListNode) -> List[int]:
        stack = []
        while head:
            stack.append(head.val)
            head = head.next
        return stack[::-1]
```

### 4.剑指 Offer 24. 反转链表

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre,cur = None, head
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre
```

### 5.剑指 Offer 35. 复杂链表的复制

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        if not head: return 
        dic = {}
        cur = head
        while cur:
            dic[cur] = Node(cur.val)
            cur = cur.next
        cur = head
        while cur:
            dic[cur].next = dic.get(cur.next)
            dic[cur].random = dic.get(cur.random)
            cur = cur.next
        return dic[head]
```

## 字符串（简单）

### 6.剑指 Offer 05. 替换空格

```python
class Solution:
    def replaceSpace(self, s: str) -> str:
        res = ''
        for i in s:
            if i == ' ':
                res += '%20'
                continue
            res += i
        return res
```

### 7.剑指 Offer 58 - II. 左旋转字符串

```python
class Solution:
    def reverseLeftWords(self, s: str, n: int) -> str:
        return s[n:] + s[:n]
```

## 查找算法（简单）

### 8.剑指 Offer 03. 数组中重复的数字

```python
class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        temp = set()  # 哈希表查找O(1)复杂度，列表O(N)复杂度
        for i in nums:
            if i not in temp:
                temp.add(i)
            else:
                return i
```

### 9.剑指 Offer 53 - I. 在排序数组中查找数字 I

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        times = 0
        for i in nums:
            if i == target:
                times += 1
        return times
```

### 10.剑指 Offer 53 - II. 0～n-1 中缺失的数字

```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        i, j = 0, len(nums) - 1
        while i <= j:
            m = (i + j) // 2
            if nums[m] == m: i = m + 1
            else: j = m - 1
        return i
```

## 查找算法（中等）

### 11.剑指 Offer 04. 二维数组中的查找

```python
class Solution:
    def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix: return False
        i, j = len(matrix) - 1, 0
        len_j = len(matrix[0])
        while i >= 0 and j < len_j:
            if target > matrix[i][j]: j += 1
            elif target < matrix[i][j]: i -= 1
            else: return True
        return False
```

### 12.剑指 Offer 11. 旋转数组的最小数字

```python
class Solution:
    def minArray(self, numbers: List[int]) -> int:
        i, j = 0, len(numbers) - 1
        while i < j:
            m = (i + j) // 2
            if numbers[m] > numbers[j]: i = m + 1
            elif numbers[m] < numbers[j]: j = m
            else: j -= 1
        return numbers[i]
```

### 13.剑指 Offer 50. 第一个只出现一次的字符

```python
class Solution:
    def firstUniqChar(self, s: str) -> str:
        dic = {}
        for i in s:
            dic[i] = not i in dic
        for k,v in dic.items():
            if v: return k
        return ' '
```

## 搜索与回溯算法（简单）

### 14.剑指 Offer 32 - I. 从上到下打印二叉树

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[int]:
        if not root:return []  # 根节点为空返回空列表
        res,queue = [], collections.deque()  
        queue.append(root)
        while queue:
            node = queue.popleft()
            res.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        return res
```

### 15.剑指 Offer 32 - II. 从上到下打印二叉树 II

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        res, queue = [], collections.deque()
        queue.append(root)
        while queue:
            temp = []
            for _ in range(len(queue)):
                node = queue.popleft()
                temp.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            res.append(temp)
        return res

```

### 16.剑指 Offer 32 - III. 从上到下打印二叉树 III

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        res, queue = [], collections.deque()
        queue.append(root)
        while queue:
            temp = collections.deque()
            for _ in range(len(queue)):
                node = queue.popleft()
                if len(res) % 2: temp.appendleft(node.val)
                else: temp.append(node.val)
                if node.left: queue.append(node.left)
                if node.right: queue.append(node.right)
            res.append(list(temp))
        return res
```

### 17.剑指 Offer 26. 树的子结构

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSubStructure(self, A: TreeNode, B: TreeNode) -> bool:
        def recur(A,B):
            if not B: return True
            if not A or A.val != B.val: return False
            return recur(A.left, B.left) and recur(A.right, B.right)

        return bool(A and B) and (recur(A, B) or self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B))
```

### 18.剑指 Offer 27. 二叉树的镜像

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def mirrorTree(self, root: TreeNode) -> TreeNode:
        if not root: return 
        temp = root.left
        root.left = self.mirrorTree(root.right)
        root.right = self.mirrorTree(temp)
        return root
```

### 19.剑指 Offer 28. 对称的二叉树

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def recur(L, R):
            if not L and not R: return True
            if not L or not R or L.val != R.val: return False
            return recur(L.left, R.right) and recur(L.right, R.left)
  
        return recur(root.left, root.right) if root else True
```

## 动态规划（简单）

### 20.剑指 Offer 10- I. 斐波那契数列

```python
class Solution:
    def fib(self, n: int) -> int:
        a, b = 0, 1
        for i in range(n):
            temp = b % 1000000007
            b = a + b
            a = temp
        return a
```

### 21.剑指 Offer 10- II. 青蛙跳台阶问题

```python
class Solution:
    def numWays(self, n: int) -> int:
        a, b = 1, 1
        for _ in range(n):
            temp = b % 1000000007
            b = a + b
            a = temp
        return a
```

### 22.剑指 Offer 63. 股票的最大利润

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        cost, profit = float('+inf'), 0 
        for price in prices:
            cost = min(cost, price)
            profit = max(profit, price - cost)
        return profit
```

## 动态规划（中等）

### 23.剑指 Offer 42. 连续子数组的最大和

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        for i in range(1, len(nums)):
            nums[i] += max(nums[i - 1], 0)
        return max(nums)
```

### 24.剑指 Offer 47. 礼物的最大价值

```python
class Solution:
    def maxValue(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        for i in range(1, m):  # 初始化第一列用行索引遍历
            grid[i][0] += grid[i - 1][0]
        for j in range(1, n):  # 初始化第一行用列索引遍历
            grid[0][j] += grid[0][j - 1]
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += max(grid[i - 1][j], grid[i][j - 1])
        return grid[-1][-1]
```

### 25.剑指 Offer 46. 把数字翻译成字符串

```python
class Solution:
    def translateNum(self, num: int) -> int:
        s = str(num)
        a = b = 1
        for i in range(2, len(s) + 1):
            c = a + b if "10" <= s[i-2:i] <= "25" else b
            a = b
            b = c
        return b
```

### 26.剑指 Offer 48. 最长不含重复字符的子字符串

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        dic = {}
        res = temp = 0
        for j in range(len(s)):
            i = dic.get(s[j], -1)
            dic[s[j]] = j
            temp = temp + 1 if temp < j - i else j - i
            res = max(res, temp)
        return res
```

## 双指针（简单）

### 27.剑指 Offer 18. 删除链表的节点

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def deleteNode(self, head: ListNode, val: int) -> ListNode:
        if head.val == val: return head.next
        pre, cur = head, head.next
        while cur and cur.val != val:
            pre, cur = cur, cur.next
        if cur: pre.next = cur.next
        return head 
```

### 28.剑指 Offer 22. 链表中倒数第 k 个节点

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -> ListNode:
        front, rear = head,head
        for _ in range(k):
            if not front: return
            front = front.next
        while front:
            rear, front = rear.next, front.next
        return rear
```

### 29.剑指 Offer 25. 合并两个排序的链表

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        cur = dum = ListNode(0)
        while l1 and l2:
            if l1.val < l2.val:
                cur.next, l1 = l1, l1.next
            else:
                cur.next, l2 = l2,l2.next
            cur = cur.next
        cur.next = l1 if l1 else l2
        return dum.next
```

### 30.剑指 Offer 52. 两个链表的第一个公共节点

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        a, b = headA, headB
        while a != b:
            a = a.next if a else headB
            b = b.next if b else headA
        return a
```

### 31.剑指 Offer 21. 调整数组顺序使奇数位于偶数前面

```python
class Solution:
    def exchange(self, nums: List[int]) -> List[int]:
        i, j = 0, len(nums) - 1
        while i < j:
            while i < j and nums[i] & 1 == 1:i += 1
            while i < j and nums[j] & 1 == 0:j -= 1
            nums[i], nums[j] = nums[j], nums[i]
        return nums
```

### 32.剑指 Offer 57. 和为 s 的两个数字

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        i, j = 0, len(nums) - 1
        while i < j:
            s = nums[i] + nums[j]
            if target > s: i += 1
            elif target < s: j -= 1
            else: return [nums[i], nums[j]]
        return []
```

### 33.剑指 Offer 58 - I. 翻转单词顺序

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join(s.strip().split()[::-1])
```

## 搜索与回溯算法（中等）

### 34.剑指 Offer 12. 矩阵中的路径

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j ,k):
            if  not 0 <= i < len(board)  or not 0 <= j < len(board[0]) or board[i][j] != word[k]: return False
            if k == len(word) - 1: return True
            board[i][j] = ''
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            board[i][j] = word[k]
            return res

        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0): return True
        return False
```

### 35.剑指 Offer 13. 机器人的运动范围

```python
class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        def dfs(i, j, si, sj):
            if i >= m or j >= n or k < si + sj or (i, j) in visited: return 0
            visited.add((i, j))
            return 1 + dfs(i + 1, j, si + 1 if (i + 1) % 10 else si - 8, sj) + \
                       dfs(i, j + 1, si, sj + 1 if (j + 1) % 10 else sj - 8) 
    
        visited = set()
        return dfs(0, 0, 0, 0)
```

### 36.剑指 Offer 34. 二叉树中和为某一值的路径

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, target: int) -> List[List[int]]:
        res, path = [], []
        def recur(node, tar):
            if not node:return 
            tar -= node.val
            path.append(node.val)
            if tar == 0 and not node.left and not node.right:
                res.append(list(path))
            recur(node.left, tar)
            recur(node.right, tar)
            path.pop()
        recur(root, target)
        return res
```

### 37.剑指 Offer 36. 二叉搜索树与双向链表

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
"""
class Solution:
    def treeToDoublyList(self, root: 'Node') -> 'Node':
        def dfs(cur):
            if not cur: return
            dfs(cur.left)
            if self.pre:
                self.pre.right, cur.left = cur, self.pre
            else:
                self.head = cur
            self.pre = cur
            dfs(cur.right)
        if not root:return 
        self.pre = None
        dfs(root)
        self.head.left, self.pre.right = self.pre, self.head
        return self.head
```

### 38.剑指 Offer 54. 二叉搜索树的第 k 大节点

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        def dfs(cur):
            if not cur:return
            dfs(cur.right)
            if self.k == 0: return
            self.k -= 1
            if self.k == 0: self.res = cur.val
            dfs(cur.left)
        self.k = k
        dfs(root)
        return self.res
```

## 排序（简单）

### 39.剑指 Offer 45. 把数组排成最小的数

```python

```
